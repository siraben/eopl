[ Generate a range of numbers ]
letrec range(start) =
  proc (stop)
    if
      =(start,stop)
    then
      emptylist
    else
      let step =
        if <(start,stop)
          then
            1
          else
            -1
      in
        cons(start, ((range +(start, step)) stop))
  in

[ Higher order function filter ]    
letrec filter(p) =
  proc (l)
    if null?(l)
    then emptylist
    else if (p car(l)) then
      cons(car(l), ((filter p) cdr(l)))
      else ((filter p) cdr(l))
  in

[ Modular arithmetic ]
let mod =
  proc(x)
    proc(y)
      let q = /(x,y) in
        let a = *(y, q) in
          -(x, a)
  in


[ Is n divisible by b? ]
let dividesq = proc(n) proc(d) zero?(((mod n) d))
  in

[ Prime loop ]

let primeq = proc(n)
  if =(n, 1)
    then false
  else
    letrec primeloop(d) =
      if <(n, *(d,d))
      then true
      else if ((dividesq n) d)
           then false
           else (primeloop +(d, 1))
      in
    (primeloop 2)
    in

((filter primeq) ((range 1) 100))
